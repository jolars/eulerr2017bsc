\PassOptionsToPackage{usenames,fixpdftex,dvipsnames,svgnames,x11names}{xcolor}

\documentclass[
  a4paper,
  nofonts,
  nobib,
  nohyper,
  openany
]{tufte-book}

\title[eulerr]{eulerr: Area-Proportional Euler Diagrams with Ellipses}

%\date{28 March 2010} % without \date command, current date is supplied

%\geometry{showframe} % display margins for debugging page layout

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[square,numbers,sort&compress]{natbib}

\usepackage{graphicx} % allow embedded images
  \setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio}
  \graphicspath{{graphics/}}

\usepackage{booktabs}
\usepackage{units}
\usepackage{xspace}
\usepackage{multicol}
\usepackage[header,page]{appendix}

% FONTS
\usepackage[lining]{libertine}
\usepackage{textcomp}
\usepackage[varqu,varl,scaled=0.95]{inconsolata}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage[libertine,vvarbb,libaltvw,liby]{newtxmath}
\usepackage[scr=rsfso]{mathalfa}
\usepackage{bm}
\useosf
\usepackage{microtype}

\usepackage[hyphens]{url}
\usepackage{hyperref}
\usepackage[noabbrev,capitalize,nameinlink]{cleveref}
\hypersetup{linkcolor=SteelBlue4,
            citecolor=SteelBlue4,
            urlcolor=SteelBlue4,
            colorlinks=true}

\usepackage{fancyvrb} % extended verbatim environments
  \fvset{fontsize=\normalsize}% default font size for fancy-verbatim environments

\newcommand{\proglang}[1]{\textsf{#1}}
\newcommand{\pkg}[1]{{\fontseries{b}\selectfont #1}}
\newcommand{\code}[1]{\texttt{#1}}

\titleformat{\section}{\normalfont\bfseries\LARGE}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\bfseries\Large}{\thesubsection}{1em}{}
\titleformat{\chapter}{\normalfont\bfseries\huge}{\thechapter}{1em}{}

%\fancyhead[RE, RO]{\small{\itshape{\rightmark}}}%
%\fancyfoot[LE,LO]{\thepage}
%\fancyfoot[RE,RO]{}
%\fancyfoot[C]{\thepage}
%\cfoot{\nouppercase{\thepage}}

% \fancypagestyle{plain}{
%   \fancyhf{}
%   \fancyfoot[LE,LO]{\thepage} % same placement as with page style "fancy"
%   \renewcommand{\headrulewidth}{0pt}
% }

%\usepackage[labelfont=bf,hypcap=false,labelsep=period]{caption}
%\captionsetup[algorithm]{labelfont=bf,hypcap=false,labelsep=period}

\usepackage{algorithm}
\usepackage{algorithmic}

\renewcommand{\maketitlepage}{%
  \cleardoublepage
  {%
  \begin{fullwidth}
  \centering
  \vspace*{3cm}
  \includegraphics[width=0.3\textwidth]{LundUniversity_C2line_BLACK}\par\vspace{1cm}
  \vspace{0.5cm}
  {\scshape\Large Bachelor Thesis \par}
  {\Huge\bfseries eulerr: Area-Proportional Euler Diagrams with Ellipses \par}
  \vspace{2cm}
  {\huge\itshape Johan Larsson \par}
  \vspace{2cm}
  {\Large{\itshape supervised by}\par Peter Gustafsson}

  \vfill

  % Bottom of the page
  {\large \today\par}
  \end{fullwidth}%
  }%
  \thispagestyle{empty}%
  \clearpage
}

% Theorems and definitions
\newtheorem{mydef}{Definition}

\begin{document}

<<setup, include = FALSE>>=
knitr::knit_hooks$set(crop = knitr::hook_pdfcrop)

mtime <- function(files) {
  lapply(Sys.glob(files), function(x) file.info(x)$mtime)
}

knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  fig.width = 2.1,
  fig.height = 2.1,
  crop = TRUE,
  fig.align = "center",
  dev = "cairo_pdf",
  dev.args = list(family = "Linux Libertine O"),
  cache = TRUE,
  fig.path = "figure/graphics-",
  cache.path = "cache/graphics-",
  cache.extra = mtime(c(file.path("data", "data_acc.rda"),
                        file.path("data", "data_consistency.rda"),
                        file.path("data", "data_performance.rda"))),
  autodep = TRUE
)

options(digits = 3)

library(grid)
library(eulerrPaper)
library(tidyverse)
library(ggthemes)
library(RConics)
library(eulerr)
library(lattice)
library(latticeExtra)
library(gridExtra)

lattice.options(default.theme = tactile::tactile.theme(fontsize = c(8, 4)))

trellis.par.set(tactile::tactile.theme(fontsize = c(8, 4)))

theme_set(theme_tufte(base_size = 8, base_family = "Linux Libertine O"))

set.seed(1)

cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
               "#0072B2", "#D55E00", "#CC79A7")
@

\frontmatter

\maketitle

{\hypersetup{linkcolor=black}
\tableofcontents
}

\mainmatter

\chapter{Background}
Visual display of data is an intuitive form of data presentation. Data visualizations work on multiple dimensions and, if done right, possess the potential to convey intricate relationships that a single statistic or table of numbers never could.

Such visualizations, however, are only informative if their aesthetics convey relationships. Consider, for instance, a disc with a radius of 2~cm labelled \emph{Men}\sidenote{
<<men, fig.width=1.45, fig.height=1.45>>=
plot(euler(c(Men = 2)))
@
}---it says nothing by itself; yet if we juxtapose it with a 1~cm-radius disc labelled \emph{Children}\sidenote{
<<children, fig.width=1, fig.height=1>>=
plot(euler(c(Children = 1)), fill = "white")
@
}, the graphic starts to become informative. Now, if we  then intersect the two discs, generating a visible overlap, \sidenote{
<<childrenMen, fig.width=2, fig.height=2>>=
plot(euler(c(Men = 2, Children = 0.6, "Children&Men" = 0.2)))
@
}, we have successfully visualized the relative proportions of men, children, and their intersection. The diagram we have constructed is a \emph{Euler diagram}.

The Euler diagram, originally proposed by Leonard Euler~\citep{euler_1802}, is the superset of the obiquiteous \emph{Venn diagram}: a staple of introductory text books in statistics and research disciplines such as biomedicine and geology. Venn and Euler diagrams differ in that the the former require all intersections to be present---even if they are empty---whilst Euler diagrams do not.

Euler diagrams may also be area-proportional, which is to say that each separate surface of the diagram is proportional to some quantity. (This was the case with the diagram with defined in the second paragraph.) This is a rational form for a Euler diagram---only its geometry is necessary to interpret it, letting us, for instance, to discard numbers without crucial loss of information; the same cannot be said for a Venn diagram.

Area-proportional Euler diagrams may be fashioned out of any closed shape, and have been implemented for triangles~\citep{swinton_2011}, rectangles~\citep{swinton_2011}, ellipses~\citep{micallef_2014}, smooth curves~\citep{micallef_2014b}, polygons~\citep{swinton_2011}, and circles~\citep{wilkinson_2012,kestler_2008,swinton_2011}. Circles are most common, and for good reason, since they are the easiest for viewers to interpret~\citep{blake_2016}. In spite of this, circles do not always lend themselves to accurate representations. Consider, for instance the following three-set relationship:
\[
\begin{gathered}
A = B = C = 2,\\
A \cap B = A \cap C = B \cap C = 1\\
A \cap B \cap C = 0.
\end{gathered}
\]
There is no way to visualize this relationship perfectly with circles because they cannot be arranged so that the $A \cap B \cap C$ overlap is empty whilst $A \cap B$, $A \cap C$, and $B \cap C$ remain non-empty. With ellipses, however, we may solve this problem since they can both be stretched and rotated, enabling a perfect fit~(\cref{fig:impossible}). In essence, we might say that circles feature three degrees of freedom: a center consisting of x- and y-coordinates~$h$ and $k$, as well as a radius $r$. Ellipses, meanwhile, have five: the aforementioned $h$ and $k$, a semi-major axis $a$, a semi-minor axis $b$, and an angle of rotation $\phi$.

\begin{marginfigure}
<<impossible, out.width="\\linewidth", fig.height=4, fig.width=2.3>>=
p1 <- plot(euler(c(A = 2, B = 2, C = 2, "A&B" = 1, "A&C" = 1, "B&C" = 1)))
p2 <- plot(euler(c(A = 2, B = 2, C = 2, "A&B" = 1, "A&C" = 1, "B&C" = 1),
                 shape = "ellipse"))

grid.arrange(p1, p2, ncol = 1)
@
\caption{A set relationship depicted erroneously with circles and perfectly with ellipses.}
\label{fig:impossible}
\end{marginfigure}

With four or more intersecting sets, exact circular Euler diagrams are in fact impossible, given that we require 15 intersections but four circles can yield at most 13 unique overlaps. This is not the case with ellipses, which may intersect in up to four, rather than two, points. The only implementation of elliptical Euler diagrams is found in \pkg{eulerAPE}~\citep{micallef_2014}, yet it only supports three sets that are moreover required to intersect.

Euler diagrams do not reduce to analytical solutions~\citep{chow_2007} and have to be solved numerically. Most dimplementations accomplish this in two steps, first finding a rough initial estimate that is then finalized in a second, more accurate, algorithm. For the initial configuration, \pkg{eulerAPE}~\citep{micallef_2013}, for instance, uses a greedy algorithm that tries to minimze the error in the three-way intersection. \pkg{venneuler}~\citep{wilkinson_2012} uses multi-dimensional scaling with jacobian distances, taking only pairwise relationships into account. \pkg{venn.js}~\citet{frederickson_2016} uses a constrained version of the latter that is instead based on euclidean distances and separately runs a greedy algorithm, picking the best fit out of the two. \pkg{Vennerable}~\citet{swinton_2011} uses a simple method of computing the required pairwise distances between circles and the changes the largest to attempt to arrive at the correct two-way overlaps. All the algorithms use circles in the initial configuration.

Diagrams with more than two sets normally require additional tuning, which may be dealt with in a final configuration step. The prerequisite for this is that we first compute the areas of the overlaps in order to establish how well our diagram fits the input. Calculating overlaps, however, is no trivial task, particularly not for ellipses. This is evident in that most methods resort to approximations such as quad-tree binning~\citep{wilkinson_2012}, polygon intersecting~\citep{kestler_2008}, or restricting the algorithm to pairwise overlaps~\citep{swiniton_2011}. \citet{frederickson_2016}, contrastingly, computes areas exactly, yet only for circles. The latter three allow only circles. \citet{micallef_2013}, on the other hand, also compute areas exactly for both circles and ellipses, though only for a maximum of three.

Compared to the approximative methods, all the exact algorithms require that we first find all the intersection points between the ellipses, for which there are several approaches. Some rely on solving the system of equations formed by two ellipses to be intersected, which necessitates solving a fourth-degree polynomial; other methods make use of the representation of an ellipse as a conic in projective geometry, which involves solving a third-degree polynomial. Whilst these methods vary in execution time, they are all accurate up to floating-point precision.

With all the intersection points at hand, the areas of the overlaps can be established using a method published in \citet{frederickson2014} for circles. A similar method is used in \citet{micallef_2013} for ellipses, yet for no more than three ellipses at a time. No method has so far been published that generalizes these methods to diagrams of more than three ellipses or, for that matter, diagrams that feature disjoint or subset relationships.

\section{Aims}
\label{sec:aims}

Elliptical Euler diagrams have previously not been implemented for more than three sets. This is the motivation for this thesis, with which we aim to present a method and implementation for constructing and visualizing Euler diagrams for sets of any numbers using ellipses and exact area computations.

\chapter{Method}
\label{ch:method}

Constructing a Euler diagram is analagous to fitting a statistical model in that you need
\begin{enumerate}
\item data,
\item a model to fit the data on,
\item a test to assess the model fit, and
\item a presentation of the result.
\end{enumerate}
In the following sections, we explain how \pkg{eulerr} adressess each of these items in turn.

\section{Input}
\label{sec:input}

The data for a Euler diagram is always a description of set relationships. \pkg{eulerr} allows several alternatives for this data, namely,
%
\begin{itemize}
\item intersections and relative complements\sidenote[][1ex]{$A \setminus B = 3 \quad B \setminus A = 2 \quad A \cap B=1$},
\item unions and identities\sidenote[][1ex]{$A=4 \quad B=3 \quad A \cap B=1$},
\item a matrix of binary (or boolean) indices\sidenote[][1ex]{$\begin{bmatrix}\bm{A} & \bm{B} & \bm{C} \\0 & 1 & 0 \\1 & 1 & 1 \\1 & 0 & 0 \\ \end{bmatrix}$},
\item a list of sample spaces\sidenote[][1ex]{$\begin{matrix} A = \{ab,\,bb,\,bc\}\\B = \{aa,\,bc,\,cc\}\\C = \{bb,\,bb,\,cc\} \end{matrix}$}, or
\item a two- or three-way table \sidenote[][1ex]{\begin{tabular}{lrr} \toprule Survived? & No  & Yes \\   \midrule Child & 52.00 & 57.00 \\   Adult & 1438.00 & 654.00 \\    \bottomrule\end{tabular}}.
\end{itemize}

As an additional feature for the matrix form, the user may supply a factor variable with which to split the data set before fitting a Euler diagram to each split. This is offered as a convenience function for the user since it may be that the solution is more well-behaved after such a split.

Whichever type of input is provided, \pkg{eulerr} translates it to the first, \emph{intersections and relative complements}~(\cref{def:omega}), which is the form used later in the loss functions of the initial and final optimizers.

\begin{mydef}
\label{def:omega}
For a family of \emph{N} sets, $F = F_1, F_2, \dots, F_N$, and their $n=2^N-1$ intersections, we define $\omega$ as the intersections of these sets and their relative complements, such that
\begin{align*}
  \omega_{1} & = F_1 \setminus \bigcap_{j=2}^N F_j  \\
  \omega_{2} & = (F_2 \cap F_3) \setminus \bigcap_{j=3}^{n} F_j\\
  \omega_{3} & = \bigcap_{i=1}^3 F_i \setminus \bigcap_{j=4}^{N} F_j\\
             & \vdotswithin{=} \\
    \omega_n & = \bigcap_{j=1}^{N}F_j
\end{align*}
with
\[
  \sum_{i = 1}^n \omega_i =  \bigcup_{j=1}^N F_j.
\]
Analogously to $\omega$, and for convenience, we also introduce the $\&$ operator as
\[
  F_j \& F_k = (F_j \cap F_k)\setminus (F_j \cap F_k)^C = \omega_{i},
\]
where $i$ in this instance is the index of the binary identifier of the intersection between $F_j$ and $F_k$.
\end{mydef}

With the input translated into a useable form, the Euler diagram is fit in two steps: first, an initial configuration is formed with circles using only the sets' pairwise relationships. Second, this configuration is fine tuned taking all $2^N-1$ overlaps into account.

\section{Initial configuration}
\label{sec:initConfig}

For our initial configuration we rely on a constrained version of multi-dimensional scaling~(MDS) from \pkg{venn.js}~\citep{frederickson_2016}, which is a modification of a method from \pkg{venneuler}~\citep{wilkinson_2012}. In it, we consider the pairwise relationsships between the sets and attempt to position their respective shapes so as to minimize the difference between the distance between their centers required to obtain an optimal overlap ($\omega$) and the actual overlap between the shapes in the diagram.

This problem is unfortunately intractable for ellipses, being that there is an infinite number of ways by which we can position two ellipses to obtain a given overlap. Thus, we restrict ourselves to circles, for which we can use the circle--circle overlap formula~\eqref{eq:circleOverlap} to numerically find the required distance, $d$, for each set of two ellipses,
\begin{fullwidth}
\begin{multline}
O_{ij} = r_i^2\arccos\left(\frac{d_{ij}^2 + r_i^2 - r_j^2}{2d_{ij}r_i}\right) +
r_j^2\arccos\left(\frac{d_{ij}^2 + r_j^2 - r_i^2}{2d_{ij}r_j}\right) - \\
\frac{1}{2}\sqrt{(-d_{ij} + r_i + r_j)(d_{ij} + r_i - r_j)(d_{ij} - r_i + r_j)(d_{ij} + r_i + r_j)},
\label{eq:circleOverlap}
\end{multline}
\end{fullwidth}
where $r_i$ and $r_j$ are the radii of the circles representing the $i$:th and $j$:th sets respectively, $O_{ij}$ their overlap, and $d_{ij}$ the distance between them.

\begin{marginfigure}[-36\baselineskip]
<<circleOverlap, fig.width=2.2, fig.height = 2.4>>=
c0 <- ellipseToConicMatrix(c(1, 1), c(0, 0), 0)
c1 <- ellipseToConicMatrix(c(0.7, 0.7), c(1.2, 0), 0)
pp <- intersectConicConic(c0, c1)

theta0 <- atan2(pp[2, 1], pp[1, 1])
theta1 <- atan2(pp[2, 2], pp[1, 2])

phi0 <- atan2(pp[2, 1], pp[1, 1] - 1.2)
phi1 <- atan2(pp[2, 2], pp[1, 2] - 1.2)

seg <- rbind(ellipse_arc(c(0.7, 0.7), c(1.2, 0), 0, n = 50, c(-pi, phi0)),
             ellipse_arc(c(1, 1), c(0, 0), 0, n = 100, c(theta0, theta1)),
             ellipse_arc(c(0.7, 0.7), c(1.2, 0), 0, n = 50, c(phi1, pi)))

ospot <- c(mean(seg[, 1]), mean(seg[, 2]))

xyplot(1~1, xlim = c(-1.1, 2), ylim = c(-1.5, 1.1), asp = "iso",
       xlab = NULL, ylab = NULL,
       scales = list(draw = FALSE),
       par.settings = list(axis.line = list(col = "transparent")),
       panel = function() {
         panel.polygon(seg, col = "steelblue1", alpha = 0.5,
                       border = "transparent")
         grid::grid.circle(0, 0, r = 1, default.units = "native",
                           gp = gpar(fill = "transparent"))
         grid::grid.circle(1.2, 0, r = 0.7, default.units = "native",
                           gp = gpar(fill = "transparent"))
         pBrackets::grid.brackets(1.2, -1.2, 0, -1.2, h = 0.05)
         pBrackets::grid.brackets(-1, 0, 0, 0, h = 0.05)
         pBrackets::grid.brackets(1.2, 0, 1.9, 0, h = 0.05)
         panel.lines(c(0, 0), c(0, -1.2), lty = 2, col = "grey65")
         panel.lines(c(1.2, 1.2), c(0, -1.2), lty = 2, col = "grey65")
         panel.text(0.6, unit(-1.3, "native"),
                    labels = expression(italic(d[ij])), pos = 1)
         panel.text(ospot[1], ospot[2], labels = expression(italic(O[ij])))
         panel.text(-0.5, 0.1, labels = expression(italic(r[i])), pos = 3,
                    default.units = "native")
         panel.text(1.55, 0.1, labels = expression(italic(r[j])), pos = 3,
                    default.units = "native")
         panel.points(c(0, 1.2), c(0, 0), pch = 21, col = 1, cex = 1,
                      fill = "white")
       })
@
\caption{The circle--circle overlap is computed as a function of the discs' separation ($d_{ij}$), radii ($r_i,r_j$), and area of overlap ($O_{ij}$).}
\label{fig:circleCircle}
\end{marginfigure}

We are looking for $d$, which we find easily from knowing $O$ and $r$. Our loss function is the squared difference between $O$ and $\omega$ (the desired overlap),
\[
  \mathcal{L}(d_{ij}) = (O_{ij} - \omega_{ij})^2, \quad \text{for } i < j \neq < n
\]
which we optimize using R's built-in \code{optimize()}\sidenote[]{According to the documentation, \code{optimize()} consists of a "combination of golden section search and successive parabolic interpolation."}. Convergence is fast and neglible next to our later optimization procedures.

Given these optimal pairwise distances, we proceed to the next step, where we position the circles representing the sets. This can be accomplished in many ways; \pkg{eulerr}

The algorithm assigns a loss and gradient of zero when the sets and their representations as circles are disjoint or when the sets and circles are subset. In all other cases, the loss function~\eqref{eq:initLoss} is the normal sums of squares between the optimal distance between two sets, $d$, that we found in~\eqref{eq:circleOverlap} and the actual distance in the layout we are currently exploring. The gradient~\eqref{eq:initGrad} is retrieved as usual by taking the derivative of the loss function.
\begin{fullwidth}
\begin{align}
\mathcal{L}(\bm{v}) = \sum_{i=1}^{N-1} \sum_{i=j+1}^{N}
& \begin{cases}
  0 & (F_i \cap F_j = \emptyset) \wedge (O_{ij} = \emptyset)\\
  0 & \left((F_i \subseteq F_j) \vee (F_i \supseteq F_j)\right) \wedge (O_{ij}=\emptyset)\\
  4 ((\bm{v}_i - \bm{v}_j)^{\scriptscriptstyle\rm T}(\bm{v}_i - \bm{v}_j) - d_{ij}^2)^2  & \text{otherwise} \\
\end{cases} \label{eq:initLoss} \\
\vec{\nabla} f(\bm{v}_i) = \sum_{i=1}^N
& \begin{cases}
  \vec{0} & (F_i \cap F_j = \emptyset) \wedge (O_{ij} = \emptyset)\\
  \vec{0} & \left((F_i \subseteq F_j) \vee (F_i \supseteq F_j)\right) \wedge (O_{ij}=\emptyset)\\
  4 \left((\bm{v}_i - \bm{v}_j)^{\scriptscriptstyle\rm T}(\bm{v}_i - \bm{v}_j) - d_{ij}^2\right) (\bm{v}_i - \bm{v}_j) & \text{otherwise}, \\
\end{cases} \label{eq:initGrad}
\end{align}
\end{fullwidth}
where $\bm{v}_i = \begin{bsmallmatrix}h_i \\ k_i\end{bsmallmatrix}$ and $\wedge,\vee$ denote the conditional \texttt{AND} and \texttt{OR} operators respectively.

We optimize~\eqref{eq:initLoss} using the nonlinear optimizer \code{nlm()} from the R core package \pkg{stats}, which is a translation from FORTRAN code developed by \citet{schnabel_1985} that uses a mix of Newton and Quasi-Newton algorithms. It makes use of the Hessian, which we presently compute numerically\sidenote{There is a bug in the current version of the package, causing the analytic Hessian to be updated incorrectly.}.

This initial configuration will be accurate for two-set combinations and optimal---although not necessarily accurate---for three-set combinations that use circles. But for all other combinations there is usually a need to fine-tune the configuration.

\section{Final configuration}
\label{sec:finalConfig}

So far, we have only considered pairwise relationships. To test and improve our layout, however, we need to account for all the relationships and, consequently, all the intersections and overlaps in the diagram. Initially, we restricted ourselves to circles but now extend ourselves also to ellipses.

As we saw in the \nameref{sec:bakground}, we now need to have all the ellipses' points of intersections at hand. \pkg{eulerr}'s approach to this is outlined in \citet{richter-gebert_2011} and based in \emph{projective}, as opposed to \emph{euclidean}, geometry.

To collect all the intersection points, we naturally need only to consider two ellipses at a time. The canonical form of an ellipse is given by
\[
\frac{\left[ (x-h)\cos{\phi}+(y-k)\sin{\phi} \right]^2}{a^2}+\frac{\left[(x-h) \sin{A}-(y-k)
  \cos{\phi}\right]^2}{b^2} = 1,
\]
where $\phi$ is the counter-clockwise angle from the positive x-axis to the semi-major axis $a$, $b$ is the semi-minor axis, and $h, k$ are the x- and y-coordinates, respectively, of ellipse's center. However, because ellipses are a special case of conics---of which the circle, ellipse, parabola, or hyperbola are members---they can also be represented as such, using the quadric form,
\[
Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0.
\]
Now, if we furthermore convert this, the quadric form, into its matrix equivalent,
\[
E = \begin{bmatrix}
      A   & B/2 & D/2 \\
      B/2 & C   & E/2 \\
      D/2 & E/2 & F
    \end{bmatrix},
\]
we have arrived at the representation of an ellipse in projective geometry required to find intersections between ellipses. Following this, we then
\begin{enumerate}
\item form a degenerate conic from the solution to the system consisting of the two conics we wish to intersect,
\item split this degenerate conic into a pencil of two lines, and finally
\item intersect the remaining conic with this pencil, yielding 0 to 4 intersection points points (\cref{fig:intersection}).
\end{enumerate}

\begin{marginfigure}[-40\baselineskip]
<<intersection, fig.height = 6, fig.width = 2.2, out.width="\\linewidth">>=
C1 <- ellipseToConicMatrix(c(8, 2), c(0, 0), -pi/3)
C2 <- ellipseToConicMatrix(c(5, 2), c(1, -2), pi/5)
ll <- Re(degenerate_split_conics(C1, C2))

ellipses <- data.frame(rbind(ellipse(c(8, 2), c(0, 0), -pi/3),
                             ellipse(c(5, 2), c(1, -2), pi/5)))
colnames(ellipses) <- c("x", "y")
ellipses$fac <- rep(c("A", "B"), each = 201)
pp <- intersectConicConic(C1, C2)

p1 <- xyplot(
  y ~ x, data = ellipses, type = "l", groups = fac, asp = 1,
  xlab = NULL, ylab = NULL,
  scales = list(draw = FALSE, axes = FALSE),
  par.settings = list(axis.line = list(col = "transparent")),
  panel = function(x, y, ...) {
    panel.xyplot(x, y, ..., col = c("black", "steelblue3"))
})
p2 <- xyplot(y ~ x, data = ellipses, type = "l", groups = fac, asp = 1,
  xlab = NULL, ylab = NULL,
  scales = list(draw = FALSE, axes = FALSE),
  par.settings = list(axis.line = list(col = "transparent")),
  panel = function(x, y, ...) {
    panel.xyplot(x, y, ..., col = c("transparent", "steelblue3"))
    panel.abline(a = -ll[3, 1]/ll[2, 1], b = -ll[1, 1]/ll[2, 1])
    panel.abline(a = -ll[3, 2]/ll[2, 2], b = -ll[1, 2]/ll[2, 2])
})
p3 <- xyplot(
  y ~ x, data = ellipses, type = "l", groups = fac, asp = 1,
  xlab = NULL, ylab = NULL,
  scales = list(draw = FALSE, axes = FALSE),
  par.settings = list(axis.line = list(col = "transparent")),
  panel = function(x, y, ...) {
    panel.xyplot(x, y, ..., col = c("transparent", "steelblue3"))
    panel.abline(a = -ll[3, 1]/ll[2, 1], b = -ll[1, 1]/ll[2, 1])
    panel.abline(a = -ll[3, 2]/ll[2, 2], b = -ll[1, 2]/ll[2, 2])
    panel.points(t(pp[1:2, ]), col = 1, pch = 21, fill = "white")
})
grid.arrange(p1, p2, p3, ncol = 1)
@
\caption{The process (from top to bottom) used to intersect two ellipses, here yielding four points.}
\label{fig:intersection}
\end{marginfigure}

After we have all the intersection points, we find the overlap by examining the intersection points that are formed from the intersections of the ellipses we are currently exploring and that are simultaneously contained within all of these ellipses. These points form a geometric shape that can be considered a polygon with elliptical segments formed by successive points of the polygon~(\cref{fig:polyarea}).

\begin{figure}[hbt]
<<polyarea, fig.height = 4.2, fig.width = 4.2>>=
x <- c(0, -0.3, 0.2)
y <- c(0, 0.1, 0.3)
ra <- a <- c(0.3, 0.5, 0.4)
rb <- b <- c(0.3, 0.3, 0.6)
phi <- c(-pi/6, 2, -2)

ee <- data.frame(x, y, ra, rb, phi)

tx <- atan2(-b*tan(phi), a)
ty <- atan2(b*tan(pi/2L - phi), a)

xlim <- range(x + a*cos(tx)*cos(phi) - b*sin(tx)*sin(phi),
              x + a*cos(tx + pi)*cos(phi) - b*sin(tx + pi)*sin(phi))
ylim <- range(y + b*sin(ty)*cos(phi) + a*cos(ty)*sin(phi),
              y + b*sin(ty + pi)*cos(phi) + a*cos(ty + pi)*sin(phi))

pp <- matrix(NA, ncol = 4, nrow = 0)

for (i in 1:2) {
  for (j in (i + 1):3) {
    e1 <- ellipseToConicMatrix(c(ra[i], rb[i]), c(x[i], y[i]), phi[i])
    e2 <- ellipseToConicMatrix(c(ra[j], rb[j]), c(x[j], y[j]), phi[j])
    pp <- rbind(pp, cbind(t(intersectConicConic(e1, e2)[1:2, ]), i, j))
  }
}

sel <- logical(nrow(pp))
for (k in 1:nrow(pp)) {
  in_which <- ((pp[k, 1] - x)*cos(phi) + (pp[k, 2] - y)*sin(phi))^2/ra^2 +
    ((pp[k, 1] - x)*sin(phi) - (pp[k, 2] - y)*cos(phi))^2/rb^2 <= 1 + 0.1
  sel[k] <- all(in_which)
}

pp <- pp[sel, ]
mid <- cbind(mean(pp[, 1]), mean(pp[, 2]))
seglines <- matrix(NA, ncol = 2, nrow = 0)

ang <- atan2(pp[, 1] - mid[1], pp[, 2] - mid[2])
ord <- order(ang)

pp <- pp[ord, ]

j <- nrow(pp)
for (i in 1:nrow(pp)) {
  k <- intersect(pp[i, 3:4], pp[j, 3:4])
  start <- atan2(pp[j, 2] - y[k], pp[j, 1] - x[k])
  stop <- atan2(pp[i, 2] - y[k], pp[i, 1] - x[k])
  arc <- ellipse_arc(c(a[k], b[k]), c(x[k], y[k]), theta = phi[k],
                     rng = c(start, stop))
  seglines <- rbind(seglines, arc)
  j <- i
}

xyplot(
  y ~ x, data = ee, asp = "iso",
  xlim = extendrange(xlim, f = 0.01), ylim = extendrange(ylim, f = 0.01),
  scales = list(draw = FALSE), xlab = NULL, ylab = NULL,
  par.settings = list(axis.line = list(col = "transparent")),
  panel = function(x, y, ...) {
    panel.euler.ellipses(x, y, ra, rb, phi, ...)
    panel.polygon(seglines, col = "slategray2")
    panel.polygon(pp[, 1:2], col = "grey90")
    panel.points(mid, pch = 4, col = 1, cex = 1.5)
    panel.points(pp[, 1:2, drop = FALSE], col = 1, pch = 21, fill = "white", cex = 1.5)
  }
)
@
\label{fig:polyarea}
\caption{The overlap area between three ellipses is the sum of a convex polygon (in \textcolor{Grey}{grey}) and 2--3 ellipse segments (in \textcolor{SteelBlue4}{blue}).}
\setfloatalignment{b}
\end{figure}

Since the polygon part is always convex, it is easy to find its area using the \emph{triangle method}. To find the areas of the elliptical segments, we first order all the points in clockwise order\sidenote{It makes no difference if we sort them in counter-clockwise order instead.}. Then, we acknowledge that each elliptical segment is formed from an arc of the ellipse that is shared by both points\sidenote{Because there is sometimes two arcs connecting the pairs of points, we simply compute both areas and pick the smaller.}. Now that we have two points on an ellipse, we can find the area of the ellipse segment using an algorithm from \citet{eberly_area_2016}. To proceed, we

\begin{enumerate}
\item center their ellipse at $(0, 0)$,
\item normalize its rotation, which is not needed to compute the area,
\item integrate the ellipse from $0$ to $\phi_0$ and $\phi_1$ to produce two elliptical sectors,
\item subtract the smaller of these sectors from the larger, and
\item subtract the triangle section to finally find the segment area~\eqref{eq:segmentArea}.
\end{enumerate}

\begin{equation*}
\alpha(\theta_0, \theta_1) = F(\theta_1) - F(\theta_0) -
\frac{1}{2}\left|x_1y_0 - x_0y_1\right|,
\label{eq:segmentArea}
\end{equation*}
\[
\text{where } F(\theta) = \frac{a}{b}\left[ \theta -
\arctan{\left(\frac{(b - a)\sin{2\theta}}{b + a +(b - a )\cos{2\theta}} \right)}
\right]
\]
This procedure is illustrated in~\cref{fig:ellipsesegment}.

\begin{marginfigure}
<<ellipsesegment, out.width = "\\linewidth", fig.width = 2.2, fig.height = 2.2>>=
ellipse <- ellipse(c(1, 0.6), c(0, 0), 0)
i0 <- 15
i1 <- 45

tri <- rbind(cbind(0, 0),
             ellipse[i0, , drop = FALSE],
             ellipse[i1, , drop = FALSE])

xyplot(1~1, xlim = c(-1.2, 1.2), ylim = c(-0.8, 0.8), asp = "iso",
       xlab = NULL, ylab = NULL,
       par.settings = list(axis.line = list(col = "transparent")),
       scales = list(draw = FALSE),
       panel = function(x, y, ...) {
         panel.grid(x = 0, y = 0, h = 1,v = 1)
         panel.lines(ellipse, col = 1)
         panel.polygon(ellipse[i0:i1, ], col = "steelblue1", alpha = 0.5)
         panel.polygon(tri, col = "grey95")
         panel.points(ellipse[c(i0, i1), ], col = 1, pch = 21, fill = "white")
         panel.text(ellipse[c(i0, i1), ],
                    adj = c(-0.5, -0.5),
                    labels = c(expression(italic(theta[0])),
                               expression(italic(theta[1]))))
                    pBrackets::grid.brackets(1, 0, 0, 0, h = 0.05,
                                  type = 1)
         pBrackets::grid.brackets(0, 0, 0, 0.6, h = 0.04)
         panel.text(0.5, unit(-0.05, "npc"), labels = "a", font = 3, pos = 1)
         panel.text(-0.05, unit(0.3, "native"), labels = "b", font = 3, pos = 2)
       })
@
\caption{The elliptical segment in \textcolor{SteelBlue4}{blue} is found by first subtracting the elliptical sector from $(a, 0)$ to $\theta_0$ from the one from $(a, 0)$ to $\theta_1$ and then subtracting the triangle part (in \textcolor{Grey}{grey}).}
\label{fig:ellipsesegment}
\end{marginfigure}

With this in place, we are now able to compute the areas of all intersections and their relative complements up to numerical precision. We feed the initial layout computed in~\nameref{sec:initConfig} to the optimizer, this time allowing the ellipses to rotate and the relation between the semiaxes vary, altogether rendering five parameters to optimize per set and ellipse. For each iteration of the optimizer, the areas of all intersections are analyzed and a measure of loss returned. The loss we use is the sum of squared errors between the ideal sizes ($\omega$ from~\cref{def:omega}) and the respective areas of the diagram,
\begin{equation}
\sum_{i=1}^{n}  (A_i-\omega_i)^2
\label{eq:loss}
\end{equation}

\section{Goodness of fit}
\label{sec:gof}

When \pkg{eulerr} cannot find a perfect solution it offers an approximate one instead, the adequacy of which has to be measured in a standardized way. For this purpose we adopt two measures: \emph{stress}~\citep{wilkinson_2012} and \emph{diagError}~\citep{micallef_2014}.

The stress metric is the residual sums of squares over the total sums of squares,
\begin{equation}
\text{Stress} = \frac{\sum_{i=1}^n (\omega_i - A_i)^2}{\sum_{i=1}^n (A_i - \bar{A})},
\label{eq:stress}
\end{equation}
where $\bar{A}$ is the arithmetic mean of the areas in the diagram.

The stress metric does not lend itself readily to a clear-cut interpretation but can be transformed into a rough analogue of the correlation coefficient by $r = \sqrt{1-\text{Stress}^2}$.

diagError, meanwhile, is given by
\begin{equation}
\text{diagError} = \max_{i = 1, 2, \dots, n} \left| \frac{\omega_i}{\sum_{i=1}^n \omega_i} -
  \frac{A_i}{\sum_{i=1}^n A_i} \right|,
\label{eq:diagError}
\end{equation}
which is the maximum absolute difference of the proportion of any $\omega$ to the respective unique area of the diagram.

\chapter{Results}
\label{ch:results}

The only R packages that feature area-proportional Euler diagrams are \pkg{eulerr}, \pkg{venneuler}, \pkg{Vennerable}, and \pkg{d3VennR}. The latter is an interface to the \pkg{venn.js} script that has been discussed previously, but because it features an outdated version of the script and only produces images as html, we refrain from using it in our results. Only \pkg{eulerr} and \pkg{venneuler} support more than 3 sets, which is why there are only 3--set results for \pkg{Vennerable}.

All of the results were computed on a PC running R version~3.4.2%
\sidenote{
  Specifically, the PC featured the following configuration:
    \begin{itemize}
      \item Microsoft Windows Pro 10 x64
      \item Intel\textregistered~Core\textsuperscript{TM} i7-4500U CPU @ 1.80GHz, 2 cores
      \item 8 Gb memory
      \item R 3.4.2, x64
    \end{itemize}
}

\section{Case studies}
\label{sec:caseStudies}

We begin our examination of \pkg{eulerr} by studying a difficult set relationship from \citet{wilkinson_2012},
\begin{gather*}
A = 4 \quad B = 6 \quad C = 3 \quad D = 2 \quad E = 7 \quad F = 3\\
A\& B = 2 \quad A\&F = 2 \quad B\& C = 2 \quad B\&D = 1 \\
B\& F = 2 \quad C\&D = 1 \quad D\& E = 1 \quad E\&F = 1 \\
A\&B\&F = 1 \quad B\&C\&D = 1,\end{gather*}
where we use the $\&$ operator as defined in~\cref{def:omega}. We fit this specification with \pkg{venneuler} and \pkg{eulerr}, in the latter case using both circles and ellipses~(\cref{fig:venneulerHard}).

This example showcases the improvement gained from using ellipses and also the small benefit that \pkg{eulerr} offers relative to \pkg{venneuler}.

\begin{figure*}[htb]%[-35\baselineskip]
\setfloatalignment{t}
<<venneulerHard, fig.height = 2.8, fig.width = 6.6>>=
set <- c(A = 4, B = 6, C = 3, D = 2, E = 7, F = 3,
         "A&B" = 2, "A&F" = 2, "B&C" = 2, "B&D" = 1,
         "B&F" = 2, "C&D" = 1, "D&E" = 1, "E&F" = 1,
         "A&B&F" = 1, "B&C&D" = 1)
p1 <- plot_venneuler(venneuler::venneuler(set))
p2 <- plot(euler(set))
p3 <- plot(euler(set, shape = "ellipse"))

grid.arrange(p1, p2, p3, ncol = 3)
@
\label{fig:venneulerHard}
\caption{A comparison of a Euler diagram generated with \pkg{venneuler} with two generated from \pkg{eulerr} with circles and ellipses respectively. The stress of the solutions are 0.006, 0.004, and 0.000 respectively.}
\end{figure*}

\section{Consistency}
\label{sec:consistency}

To compare the consistency among \pkg{eulerr}, \pkg{venneuler}, and \pkg{Vennerable}, we simulate random circles and ellipses, compute their areas, and attempt to reproduce the original diagram using the software packages that we are studying. We run the simulation through 100 iterations for each number of sets, $i = 3,4,\dots,8.$

For the circles, we sample radii ($r_i$) and coordinates ($h_i$ and $k_i$) from
\begin{equation}
\begin{aligned}
r_i     & \sim \mathcal{U}(0.3, 0.6)\\
h_i,k_i & \sim \mathcal{U}(0, 1).
\end{aligned}
\label{eq:consistencyCircles}
\end{equation}
Next, we compute the required areas, $\omega$ (from~\cref{def:omega}), for each iteration and fit a Euler diagram using the aforementioned packages. Finally, we compute and return \emph{diagError}~\eqref{eq:diagError} and score each diagram as a \emph{success} if its \emph{diagError} is lower than 0.01, that is, if no portion of the diagram is 1\% off (in absolute terms) from that of the input; note that this is theoretically achievable since our Euler diagrams are formed from sampled circles that all have perfect solutions. The left panel of \cref{fig:consistency} shows the results of our simulation.

Next, we repeat this experiment with ellipses instead of circles, this time with semiaxes ($a_i$ and $b_i$), coordinates ($x_i$ and $y_i$), and rotation axes ($\phi_i$) drawn from
%
\begin{equation}
\begin{aligned}
h_i,k_i & \sim \mathcal{U}(0, 1)\\
a_i,b_i & \sim \mathcal{U}(0.2, 0.8)\\
\phi_i  & \sim \mathcal{U}(0, 2\pi).
\end{aligned}
\label{eq:consistencyEllipses}
\end{equation}
%
The algorithm is formalized in~\cref{alg:consistency}.

\begin{algorithm}[htb]
\setfloatalignment{t}
\caption{The algorithm we use to simulate circles and ellipses, compute their areas, and use these to fit Euler diagrams using the different software packages.}
\label{alg:consistency}
\begin{algorithmic}[1]
\FOR{$i = 3,4,\dots, 8$}
  \FOR{$j = 1,2,\dots, 100$}
    \IF{Circle}
      \STATE $h,k    \leftarrow \mathcal{U}(0, 1)$
      \STATE $r      \leftarrow \mathcal{U}(0.3, 0.6)$
      \STATE $\omega \leftarrow \mathtt{ findOverlaps}(h, k, r)$
    \ELSIF{Ellipse}
      \STATE $h,k    \leftarrow \mathcal{U}(0, 1)$
      \STATE $a,b    \leftarrow \mathcal{U}(0.2, 0.8)$
      \STATE $\phi   \leftarrow \mathcal{U}(0, 2\pi)$
      \STATE $\omega \leftarrow \mathtt{ findOverlaps}(h, k, a, b, \phi)$
    \ENDIF
    \STATE $A \leftarrow \mathtt{ fitDiagram}(\omega)$
    \STATE $\text{diagError} \leftarrow \max_{k=1,2,\dots,2^i-1} \left| \frac{\omega_k}{\sum \omega_k} - \frac{A_k}{\sum A_k} \right|$
    \STATE $\text{Stress} \leftarrow \frac{\sum (\omega - A_k)^2}{\sum (A_k - \bar{A})^2}$
  \ENDFOR
\ENDFOR

\end{algorithmic}
where $n$ is the
\end{algorithm}

%
\begin{figure}[hbtp]
<<consistency, fig.height = 2.3, fig.width = 4.25, out.width = "\\linewidth">>=
data_consistency %>%
  spread(metric, loss) %>%
  mutate(success = diagError < 0.01, sets = as.integer(sets)) %>%
  select(sets, success, shape, software) %>%
  group_by(sets, shape, software) %>%
  summarise(success_rate = mean(success, na.rm = TRUE)) %>%
  mutate(success_rate = success_rate*100) %>%
  ggplot(aes(x = sets, y = success_rate, group = software, color = software, fill = software)) +
    xlab("Sets") +
    ylab("Success rate (%)") +
    scale_color_manual(values = cbPalette) +
    scale_fill_manual(values = cbPalette) +
    geom_line() +
    geom_point(size = 2, shape = 21, colour = "white", stroke = 1) +
    facet_grid(~shape) +
    theme(legend.title = element_blank(), legend.position = "top")
@
\caption{Reproducibility tests for ellipses and circles generated from the distributions from \eqref{eq:consistencyCircles}. Note that \pkg{Vennerable} only supports Euler diagrams for three sets, which is why its data is absent for the other cases.}
\label{fig:consistency}
\end{figure}
%

<<consistencyMetrics, include = FALSE>>=
consistency_eulerr_ellipse <- data_consistency %>%
  filter(software == "eulerr", shape == "ellipse", metric == "diagError") %>%
  mutate(success = loss < 0.01) %>%
  group_by(sets) %>%
  summarize(m_success = mean(success))

consistency_vennerable_circle <- data_consistency %>%
  filter(software == "vennerable", metric == "diagError") %>%
  mutate(success = loss < 0.01) %>%
  summarize(m_success = mean(success, na.rm = TRUE)) %>%
  as_vector()

vennerable_na <- data_consistency %>%
  filter(software == "vennerable", metric == "diagError", is.na(loss)) %>%
  summarize(n()) %>%
  as.vector()
@

\pkg{eulerr} outperforms both \pkg{Vennerable} and \pkg{venneuler} in consistency~\cref{fig:consistency}. It is able to reproduce Euler diagrams for almost all of the circles and for all three-set ellipses. For ellipses of four or more sets, the consistency drops considerably, yet remains above \Sexpr{100*min(consistency_eulerr_ellipse$m_success)}\%. \pkg{Vennerable}, which is only able to produce three-set diagrams, only produces accurate diagrams for \Sexpr{100*consistency_vennerable_circle}\% of the random layouts and moreover fails with an error in \Sexpr{vennerable_na} cases.

\section{Accuracy}
\label{sec:accuracy}

In \nameref{sec:consistency}, we assess the efficacy in reproducing diagrams with exact, but unknown, solutions. In real situations, however, we are often faced with set configurations that lack exact solutions, in which case we want our method to produce an approximation that is as accurate as possible.

To assess this, we generate random set relationships, that may or may not have exact solutions, and fit Euler diagram using the software under study. For each $N=3,4,\dots,8$ sets we initialize $2^N-1$ permutations of set combinations and select one for each set, initializing these to a numer in $\mathcal{U}(0, 1)$. After this, we pick 0 to $\binom{N-2}{1}$ elements from the $2^N-N-1$ remaining permutations and assign to them a random in $\mathcal{U}(0, 1)$ as before. The algorithm is formalized in~\cref{alg:accuracy}

\begin{algorithm}[htb]
\setfloatalignment{t}
\caption{The algorithm we use to simulate random set relationships and fit them with the software under study to assess their accuracy.}
\label{alg:accuracy}
\begin{algorithmic}[1]

\FOR{$N=3,4,\dots,8$}
  \STATE initialize $\omega = \{\omega_1,\omega_2,\dots,\omega_{2^N-1} \}$ to zero
  \FOR{$i=1,2,\dots,N$}
    \STATE $j \leftarrow$ random index in $\{\omega : \omega \cap F_i \neq \emptyset\}$
    \STATE $\omega_j \leftarrow \mathcal{U}(0, 1)$
  \ENDFOR
  \STATE $\omega_S \leftarrow \mathcal{U}\{0, N\}$ random elements from $\{\omega : \omega = 0\}$
  \STATE $\omega_S \leftarrow \mathcal{U}(0, 1)$
  \STATE fit a Euler diagram to $\omega$
\ENDFOR
\end{algorithmic}
\end{algorithm}

The error in the diagrams generated with \pkg{eulerr} is considerably lower than for the other methods. This is most apparent with ellipses but also true for circles compared to \pkg{venneuler} and \pkg{Vennerable}.

\begin{figure*}[hbt]
<<accuracy, fig.height = 3, fig.width = 6.6, out.width = "\\linewidth">>=
data_accuracy %>%
  filter(!is.na(Loss)) %>%
  mutate(Sets = as.factor(Sets)) %>%
  ggplot(aes(x = Sets, y = Loss, fill = Software, color = Software)) +
  geom_tufteboxplot(median.type = "line", whisker.type = "line", width = 6,
                    hoffset = 0, voffset = 0.005,
                    position = position_dodge(width = 0.5)) +
  scale_color_manual(values = cbPalette) +
  scale_fill_manual(values = cbPalette) +
  ylab(NULL) +
  facet_grid(Metric ~ ., scales = "free", switch = "y") +
  theme(legend.title = element_blank(), legend.position = "right",
        strip.placement = "outside")
@
\caption{Accuracy tests of set relationships that may or may not have perfect solutions, generated from~\eqref{eq:consistencyEllipses}.}
\label{fig:accuracy}
\end{figure*}

\section{Performance}
\label{sec:performance}

Using the same method as in \nameref{sec:accuracy}, we generate random set relationships and measure the time it takes for each software package to form a diagram from the fit. We rely on \pkg{microbenchmark} to compute this, subtracting function call times to produce strict measurement. In addition, we randomize the order in which the packages are called between trials.

\begin{figure*}[hbt]
<<performance, fig.height = 2.5, fig.width = 6.6, out.width = "\\linewidth">>=
data_performance %>%
  filter(!is.na(Time)) %>%
  mutate(Sets = as.factor(Sets), Time = Time/1000000000) %>%
  ggplot(aes(x = Sets, y = Time, fill = Software, color = Software)) +
  geom_tufteboxplot(median.type = "line", whisker.type = "line", width = 6,
                    hoffset = 0, voffset = 0.005,
                    position = position_dodge(width = 0.5)) +
  scale_fill_manual(values = cbPalette) +
  scale_color_manual(values = cbPalette) +
  scale_y_log10(labels = scales::comma) +
  ylab(expression(log[10](time[s]))) +
  theme(legend.title = element_blank())
@
\caption{Performance of \pkg{eulerr}, \pkg{venneuler}, and \pkg{Vennerable} on random set relationships of 3 to 8 sets }
\label{fig:performance}
\end{figure*}

\chapter{Discussion}
\label{sec:discussion}

In this paper, we have presented a novel method for generating Euler diagrams for any number of sets using ellipses. We have shown that the method is superior in both accuracy and consistency next to all other software packages for R---even when the method is restricted to circles. In addition, the method is speedier than the competition for set relationships with up to six sets, wherafter it performs worse than \pkg{venneuler}.

In terms of consistency and accuracy, there are several reasons for why \pkg{eulerr} improves upon the method in \pkg{venneuler} and \pkg{Vennerable}. The primary reason lies in the use of ellipses rather than circles. Ellipses feature two additional degrees of freedom and are therefore able to accurately represent a larger variety of relationships.

Moreover, the initial optimizer in \pkg{eulerr} circumvents a rule in \pkg{venneuler} that puts unnecessary restrictions on layouts that include disjoint or subset relationships. The initial optimizer in venneuler places disjoint and subset circles exactly neck-in-neck and at the exact midpoint of the set respectively. Yet, because we are indifferent about where in the space outside (or respectively inside) the circles are placed, that behavior becomes problematic since it might interfere with locations of other sets that need to use that space. The MDS algorithm from \pkg{venn.js} circumvents this by assigning a loss and gradient of zero when the pairwise set intersection \emph{and} the candidate circles are disjoint or subset.

For 3 to 7 sets, \pkg{eulerr} is speedier than both \pkg{Vennerable} and \pkg{venneuler}. The reasons for this is partly to do with the implementation in C++ using high-performance interfaces such as \pkg{Rcpp}~\citep{eddelbuettel_2011} and \pkg{RcppArmadillo}~\citep{eddelbuettel_2014}. For few sets, the exact-area calculations that \pkg{eulerr} features also promote better performance; yet, paradoxically, this also happens to be the reason for why the performance of \pkg{eulerr} suffers as the number of sets surge. The bottleneck is the final optimizer. It has to examine every possible intersection when computing the areas, thus converging in $\mathcal{O}(2^n)$ time. \citet{wilkinson_2012}, meanwhile, report convergence in $\mathcal{O}(n)$ time. This is clearly evidenced in \cref{fig:performance}. Future versions of this algorithm might consider implementing approximate area-calculations when the number of sets is large.

This method was first published for circles in a blog post~\citep{frederickson_2013} and in a scholarly paper for up to three ellipses~\citep{micaleff_2013} but has to our knowledge not previously been generalized to any number of ellipses.

The authors motivate this limitation by the propensity of Euler diagrams with more sets to lack adequate solutions and that their complexity make implementations difficult~\citep{micallef_2013}.

\begin{appendices}
\chapter{Appendix A: Visualization}

Once we have ascertained that our Euler diagram fits well, we can turn to visualizing the solution. For this purpose, \pkg{eulerr} leverages the \pkg{Lattice} graphics system~\citep{sarkar_2008} for R to offer intuitive and granular control over the output.

Plotting the ellipses is straightforward using the parametrization of a rotated ellipse,
%
\begin{equation*}
\begin{bmatrix}
  x \\ y
\end{bmatrix} =
\begin{bmatrix}
  h + a \cos{\theta} \\
  k + b \sin{\theta}
\end{bmatrix},\quad \text{where } \theta \in [0, 2\pi].
\end{equation*}
%
Often, however, we would also like to label the ellipses and their intersections with text and this is considerably more involved.

\section{Labeling}
\label{sec:labeling}

Labeling the ellipses is difficult because the shapes of the intersections often are irregular, lacking a well-defined center; we know of no analytical solution to this problem. As usual, however, the next-best option turns out to be a numerical one. First, we locate a point that is inside the required region by spreading points across the discs involved in the set intersection. To distribute the points, we use a modification of \emph{Vogel's method}~\citep{arthur_2015,vogel_1979} adapted to ellipses. Vogel's method spreads points across a disc using
\begin{equation}
p_k =
\begin{bmatrix}
  \rho_k \\
  \theta_k
\end{bmatrix} =
\begin{bmatrix}
  r \sqrt{\frac{k}{n}}\\
  \pi (3 - \sqrt{5})(k - 1)
\end{bmatrix}\quad\text{for } k = 1, 2,\dots, n.
\label{eq:vogel}
\end{equation}
In our modification, we scale, rotate, and translate the points formed in~\eqref{eq:vogel} to match the candidate ellipse. We rely, as before, on projective geometry to carry out the transformations in one go:
\[
p' =
\begin{bmatrix}
  x' \\
  y' \\
  1
\end{bmatrix} =
\begin{bmatrix}
  1 & 0 & h \\
  0 & 1 & k \\
  0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
  \cos{\phi}  & \sin{\phi} & 0 \\
  -\sin{\phi} & \cos{\phi} & 0\\
  0           & 0          & 1
\end{bmatrix}
\begin{bmatrix}
  a & 0 & 0 \\
  0 & b & 0 \\
  0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
  \hat{x} \\
  \hat{y} \\
  1
\end{bmatrix}
\]
After we spread our points throughout the ellipse and find a point, $p'_i$, that is contained in our desired intersection, we proceed to optimize its position numerically. The position we are looking for is that which maximizes the distance to the closest ellipse in our diagram to provide as much margin as possible for the label. This is a maximin problem with a loss function equal to
\begin{equation}
\max_{x,y \in \mathbb{R}^2} \min_{i=1,2,\dots,N} f(x,y,h_i,k_i,a_i,b_i,\phi_i)
\label{eq:lossDist}
\end{equation}
where $f$ is the function that determines the distance from a point ($x,y$) to the ellipse defined by $h,k,a,b$ and $\phi$.

Similarly to fitting Euler diagrams in the general case, there appears to be no analytical solution tocomputig the distance from a point to an ellipses. The numerical solution we use has been described in [ref] and involves a bisection optimizer.

To optimize this, we employ a version of the \emph{Nelder--Mead Method}~\citep{nelder_1965} which has been translated from \citet{kelley_1999} and adapted for \pkg{eulerr} to ensure that quick convergence and that the simplex remains within the intersection boundaries (since we want the local maximum). The method is visualized in~\cref{fig:vogel}.
\begin{marginfigure}
<<vogel, out.width="\\linewidth", fig.height = 6>>=
h <- c(0.2, 0.6)
k <- c(0.4, 0.4)
a <- c(0.4, .5)
b <- c(0.3, 0.6)
phi <- c(2.5, -1)
n <- 250
seqn <- seq(1, n, 1)
theta <- seqn*pi*(3 - sqrt(5))
rad <- sqrt(seqn/n)
x <- rad*cos(theta)
y <- rad*sin(theta)
p <- rbind(x, y, 1)

# Scale, rotate and translate to match the ellipse
p0 <- translation(c(h[1], k[1])) %*%
   rotation(-phi[1]) %*%  scaling(c(a[1], b[1])) %*% p

inside <- ((p0[1, ] - h[2])*cos(phi[2]) + (p0[2, ] - k[2])*sin(phi[2]))^2/a[2]^2 +
  ((p0[1, ] - h[2])*sin(phi[2]) - (p0[2, ] - k[2])*cos(phi[2]))^2/b[2]^2 <= 1

# Set up limits
tx <- atan2(-b*tan(phi), a)
ty <- atan2(b*tan(pi/2L - phi), a)

xlim <- range(h + a*cos(tx)*cos(phi) - b*sin(tx)*sin(phi),
              h + a*cos(tx + pi)*cos(phi) - b*sin(tx + pi)*sin(phi))
ylim <- range(k + b*sin(ty)*cos(phi) + a*cos(ty)*sin(phi),
              k + b*sin(ty + pi)*cos(phi) + a*cos(ty + pi)*sin(phi))

p1 <- xyplot(
  x ~ y, aspect = "iso", pch = 20, xlab = "", ylab = "",
  col = 1,
  xlim = extendrange(xlim, f = 0.01),
  ylim = extendrange(ylim, f = 0.01),
  par.settings = list(axis.line = list(col = "transparent")),
  scales = list(draw = FALSE),
  panel = function(x, y, ...) {
    panel.points(t(p0[1:2, !inside]), pch = 19, col = "grey80", cex = 0.5)
    panel.points(t(p0[1:2, inside]), pch = 19, col = "steelblue2", cex = 0.5)
    panel.points(t(p0[1:2, !inside][, 14]), pch = 19, col = 1, cex = 0.5)
    panel.polygon(ellipse(c(a[1], b[1]), c(h[1], k[1]), phi[1]))
    panel.polygon(ellipse(c(a[2], b[2]), c(h[2], k[2]), phi[2]))
  })

centers <- eulerr:::locate_centers(h, k, a, b, phi, 1:2)

p2 <- xyplot(
  x ~ y, aspect = "iso", pch = 19, xlab = "", ylab = "",
  col = 1,
  xlim = extendrange(xlim, f = 0.01),
  ylim = extendrange(ylim, f = 0.01),
  par.settings = list(axis.line = list(col = "transparent")),
  scales = list(draw = FALSE),
  panel = function(x, y, ...) {
    panel.arrows(p0[1, !inside][14], p0[2, !inside][14],
                 centers[1, 1], centers[2, 1],
                 length = 0.05, col = "grey70")
    panel.points(t(p0[1:2, !inside][, 14]), pch = 19, col = 1, cex = 0.5)
    panel.polygon(ellipse(c(a[1], b[1]), c(h[1], k[1]), phi[1]))
    panel.polygon(ellipse(c(a[2], b[2]), c(h[2], k[2]), phi[2]))
  })

p3 <- xyplot(
  x ~ y, aspect = "iso", pch = 19, xlab = "", ylab = "",
  col = 1,
  xlim = extendrange(xlim, f = 0.01),
  ylim = extendrange(ylim, f = 0.01),
  par.settings = list(axis.line = list(col = "transparent")),
  scales = list(draw = FALSE),
  panel = function(x, y, ...) {
    panel.text(t(centers[1:2, 1]), labels = "42")
    panel.polygon(ellipse(c(a[1], b[1]), c(h[1], k[1]), phi[1]))
    panel.polygon(ellipse(c(a[2], b[2]), c(h[2], k[2]), phi[2]))
  })

grid.arrange(p1, p2, p3, ncol = 1)
@
\caption{The method eulerr uses to locate an optimal position for a label in three steps from top to bottom: first, we spread sample points on one of the ellipses and pick one inside the intersection of interest, then we begin moving it numerically, and finally place our label.}
\label{fig:vogel}
\end{marginfigure}

\section{Aesthetics}
\label{sec:aesthetics}

Euler diagrams display both quantitative and qualitative data. The quantitative aspect is the quantities or sizes of the sets depicted in the diagram and is visualized by the relative sizes, and possibly the labels, of the areas of the shapes---this is the main focus of this paper. The qualitative aspects, meanwhile, consist of the mapping of each set to some quality or category, such as having a certain gene or not. In the diagram, these qualities can be separated through any of the following aesthetics:
%
\begin{itemize}
\item color,
\item border type,
\item text labelling,
\item transperancy,
\item patterns,
\end{itemize}
%
or a combination of these. The main purpose of these aethetics is to separate out the different ellipses so that the audience may interpret the diagram with ease and clarity.

Among these aesthetics, the best choice (from a viewer perspective) appears to be color~\citep{blake_2016}, which provides useful information without extraneous chart junk~\citep{tufte_2001}. The issue with color, however, is that it cannot be perceived perfectly by roughly 10\% of all people. Moreover, color is often printed at a premium in scientific publications and adds nothing to a diagram of two shapes.

For these reasons, \pkg{eulerr} defaults to distinguishing ellipses with color using a color palette generated via the R package \pkg{qualpalr}~\citep{larsson_2016}, which automatically generates qualitative color palettes based on a perceptual model of color vision that optionally caters to color vision deficiency. This palette has been manually modified slightly to fullfil our other objectives of avoiding using colors for two sets.

<<colorexamle, fig.cap = "The eight first colors of the default color palette.", fig.width = 4.2, fig.height = 3>>=
set.seed(2)
con <- c(A = 1, B = 1, C = 1, D = 1, E = 1, F = 1, G = 1, H = 1,
         "A&B" = 0.2, "B&C" = 0.2, "C&D" = 0.2, "D&E" = 0.2, "E&F" = 0.2,
         "F&G" = 0.2, "G&H" = 0.2)
plot(euler(con), labels = as.character(1:8), auto.key = F)
@

\section{Normalizing dispered layouts}
\label{sec:layout}

A side effect of running an unconstrained optimizer (See \nameref{sec:finalConfig}) is that we almost invariably produce overdispersed layouts if there are disjoint clusters of ellipses. To solve this, we use a SKYLINE-BL rectangle packing algorithm~\citep{jylanki_2010} which is designed specifically for \pkg{eulerr}. In it, we surround each ellipse cluster with a bounding box and pack these boxes into a bin with an appropriate size and aspect ratio of the golden rule.

\end{appendices}

\backmatter

\bibliography{eulerr}
\bibliographystyle{unsrtnat}

\end{document}
