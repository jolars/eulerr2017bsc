---
title: "eulerr: Area-Proportional Euler Diagrams with Ellipses"
subtitle: "Bachelor Thesis"
author:
  - name: "Johan Larsson"
  - name: "Peter Gustafsson"
affil:
  - name: "Lund University"
date: "`r Sys.Date()`"
automark: yes
colorlinks: yes
fontpack-libertine: yes
classoption:
  - headsepline=true
  - headings=standardclasses
biblatex: yes
biblio-style: ieee
header:
  - pos: ro
    next: eulerr
caption:
  - labelfont=bf
  - labelsep=period
  - font=small
setkomafont:
  - element: descriptionlabel
    commands: \normalfont\scshape\bfseries
bibliography: "eulerr.bib"
output:
  komadown::scrartcl:
    keep_tex: yes
    fig_caption: yes
    pandoc_args: --biblatex
vignette: >
  %\VignetteIndexEntry{eulerr: Area-Proportional Euler Diagrams with Ellipses}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::knit_hooks$set(crop = knitr::hook_pdfcrop)

knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  fig.width = 3,
  fig.height = 3,
  crop = TRUE
)

options(digits = 3)

library(lattice)
lattice.options(default.theme = list(fontsize = list(text = 8, points = 4)))

set.seed(1)

library(RConics)
library(eulerr)
source(file.path("R", "geometry.R"))
```

# Background

Relationships between groups and sets are the focus of many scientific
disciplines. In biomedicine, for instance, the overlap between sets of genes
is often of interest. In epidemiology, the interactions between
diseases are frequently studied. Likewise, the social sciences are often
involved in studying demographics where the commonalities between various
groups are analyzed.

Visualizations of such relationships are central to understanding them.
The commonest visualization is Venn diagrams. Venn diagrams are a 
subset of Euler diagrams, which were originally proposed by Leonard Euler
(1707--1783) [@euler_1802]. Whereas Venn diagrams require that all
$2^n$ possible intersection are present -- even if they are empty -- Euler
diagrams stipulate no such requirement.

Euler diagrams can be area-proportional, which is the case for non-Venn
diagrams. Area-proportional diagrams are most easily understood as their
interpretations do not depend on any numbers. This paper will henceforth be
concerned only with such designs and the term *Euler diagram* will be
considered to refer to area-proportional diagrams.

Euler diagrams may be fashioned with any conceivable closed shape.  
Solutions have been developed for triangles [@swinton_2011],
rectangles [@swinton_2011], ellipses [@micallef_2014],
smooth curves, polygons [@swinton_2011], and
circles [@wilkinson_2012; @kestler_2008; @swinton_2011]. The latter is 
most common, and appears to be preferred for optimal
readability [citation]. Yet circles do not always lend themselves to
accurate representations. Consider, for instance the combination 
\[
\begin{gathered}
A = B = C = 2,\\
A \cap B = A \cap C = B \cap C = 1, \text{ and}\\
A \cap B \cap C = 0.
\end{gathered}
\]
There is no way to visualize this relationship perfectly with circles
yet with ellipses there *is* in fact a perfect solution
(Figure \@ref(fig:impossible3)).

```{r impossible3, fig.cap ="A set relationship depicted with circles and ellipses.", fig.width = 6}
library(eulerr)
library(latticeExtra)
p1 <- plot(euler(c(A = 2, B = 2, C = 2, "A&B" = 1, "A&C" = 1, "B&C" = 1)))
p2 <- plot(euler(c(A = 2, B = 2, C = 2, "A&B" = 1, "A&C" = 1, "B&C" = 1),
                 shape = "ellipse"))
c(p1, p2)
```

With four intersecting sets, circular Euler diagrams are actually impossible,
given that $2^4=16$ regions are required but the circles can yield at most
14 unique intersections. This is not, however, the case with ellipses in that
they they may intersect in up to 4, rather than 2, points. All in all,
circles have three degrees of freedom: x-coordinate, y-coordinate, and
radius, whereas ellipses have five: x-coordinate, y-coordinate, semi-minor
radius, semi-major radius, and rotation.

Elliptical Euler diagrams have been successfully implemented in the 
**eulerAPE** software [@micallef_2014], yet only for three sets that moreover
need to intersect, the motivation for which being that Euler diagrams
with more than three sets often lack adequate solutions and that their
high complexity make implementations difficult [@micallef_2013].

As far as we know, analytical solutions to eulerr diagrams do not exist. All
existing implementations are instead based on varying numerical methods. 
Most of these use separate methods for the initial and final diagram
configurations. For instance,
@micallef_2013 uses uses a greedy algorithm, @wilkinson_2012 uses
multi-dimensional scaling with jacobian distances -- a constrained version of
which is used in @frederickson_2016 in combination with a greedy algorithm. The
latter two work only on pairwise relationships between the sets while the first
tries to optimize the three-way intersection between the three sets. All use
circles for the initial layout.

Diagrams with more than two sets require additional tuning, which is considered
in a final configuration step. This is always an optimization procedure with
a target loss function and an optimization procedure.

It is this difficulty that we have overcome with **eulerr**, which is the
first software to provide elliptical Euler diagrams for, theoretically, any
number of sets.

## Aim

The aim of this thesis is to present a method and implementation for
constructing and visualizing Euler diagrams for sets of any numbers with
ellipses.

# Method

Constructing a Euler diagram is in many ways analagous to fitting a
statistical model, in that you need

* data,
* a model to fit the data on,
* test to see that the model fits well, and
* a presentation of the result.

## Input

Every Euler diagram begins with data that, in one way or another, is always
a description of set relationships. **eulerr** tries to be as friendly as
possible, catering to many forms of input that principally can be 
divided into four different types (Table \@ref(tab:data)). 

Table: (\#tab:data) Types of data.

Form                                      Example
-----------------------------------       ---------------------
Intersections and relative complements    $A \setminus B = 3 \quad B \setminus A = 2 \quad A \cap B=1$
Unions and identities                     $A=4 \quad B=3 \quad A \cap B=1$
Matrix of logicals or binaries            $$\begin{bmatrix}\bm{A} & \bm{B} & \bm{C} \\0 & 1 & 0 \\1 & 1 & 1 \\1 & 0 & 0 \\ \end{bmatrix}$$
A list of sample spaces                   $$\begin{matrix} A = \{ab,\,bb,\,bc\}\\B = \{aa,\,bc,\,cc\}\\C = \{bb,\,bb,\,cc\} \end{matrix}$$


## Initial configuration

For our initial configuration, we work exclusively with circles. We begin by
mapping the disjoint set combinations to areas and, given these, figure out the
required pairwise distance between the sets to achieve a circle--circle overlap
matching these disjoint set combinations. We do this numerically, using the 
formula for a circle--circle overlap,

\begin{multline}
A = r_1^2\arccos\left(\frac{d^2 + r_1^2 - r_2^2}{2dr_1}\right) + 
r_2^2\arccos\left(\frac{d^2 + r_2^2 - r_1^2}{2dr_2}\right) - \\
\frac{1}{2}\sqrt{(-d + r_1 + r_2)(d + r_1 - r_2)(d - r_1 + r_2)(d + r_1 + r_2)},
\end{multline}

where $r_1$ and $r_2$ are the radii of the first and second circles
respectively and *d* the distance between them.

Although $r_1$ and $r_2$ are known, *d* is not, wherefore we approximate it
numerically. Here, our loss function is
the squared difference between *A* and the desired overlap, $(A-D)^2$,
which we then ptimize using the **R**'s built-in `optimize()`: a
"combination of golden section search and successive parabolic interpolation."
Convergence is fast and neglible in relation to our later, more demanding,
operations.

Given these optimal pairwise distances, we can proceed to the next step,
which is to position the circles representing the sets. This can be accomplished
in many ways; **eulerr** uses a method from the **venn.js** script
[@frederickson_2016], namely a constrained version of multi-dimensional scaling
(MDS), which is based on a similar method from the **venneuler** package
[@wilkinson_2012]. **venneuler** tries to place disjoint and subset exactly
neck-in-neck and at the 
exact midpoint of the set respectively. However, since we are indifferent about
where in the space outside (or respectively inside) the sets are placed, that
behavior becomes problematic since it might interfere with locations of other
sets that need to use that space.

The MDS algorithm from **venn.js** circumvents this by assigning a loss and gradient
of 0 when, for instance, the set relationsships *and* the candidate ellipses are
disjoint. Then, to optimize the pairwise relationsships between sets, **eulerr**
uses the following loss and gradient functions.

> \[\small
> \text{loss} = \sum_i \sum_j { {\begin{cases}
>     0 & \text{disjoint}(i, j)\\ 
>     0 & \text{subset}(i, j)\\ 
>     ((X_{i} - X_{j})^T(X_{i} - X_{j}) - D_{ij}^2) ^2  & \text{otherwise} \\ 
> \end{cases}}}
> \]
>
> \[\small
> \nabla f(X_{i}) = \sum_j {\begin{cases}
>      \vec{0} & \text{disjoint}(i, j)\\ 
>      \vec{0} & \text{subset}(i, j)\\ 
>      4 {((X_{i} - X_{j})^T(X_{i} - X_{j}) - D_{ij}^2)} (X_{i} -
>      X_{j}) & \text{otherwise} \\ 
> \end{cases}}\]
> *Source: [Better Venn Diagrams](http://www.benfrederickson.com/better-venn-diagrams/)
> by Ben Fredrickson, which includes a nice interactive demonstration.*

Fredrickson uses the *Polak--Ribière Conjugate Gradient Method* to optimize
the initial layout. In our experience this method occasionally runs into
local minima, which is why
we have opted to use `nlm()` from the **R** core package `stats`, which is a 
translation from FORTRAN code developed by @schnabel_1985 and uses a mixture of
algorithms (Newton and Quasi-Newton).

This initial configuration will work perfectly for any 1--2 set combinations
and as well as possible with 3 sets if we use circles but for all other
combinations there is usually a need to fine tune the configuration.

## Final configuration

### Intersection between ellipses

Splitting a conic

```{r, fig.cap = "The process (from left to right) used to intersect two ellipses, here yielding 4 points.", fig.width = 6, fig.height = 2}
C1 <- RConics::ellipseToConicMatrix(c(8, 2), c(0, 0), -pi/3)
C2 <- RConics::ellipseToConicMatrix(c(5, 2), c(1, -2), pi/5)
ll <- Re(degenerate_split_conics(C1, C2))

ellipses <- data.frame(rbind(ellipse(c(8, 2), c(0, 0), -pi/3),
                             ellipse(c(5, 2), c(1, -2), pi/5)))
colnames(ellipses) <- c("x", "y")
ellipses$fac <- rep(c("A", "B"), each = 201)
pp <- intersectConicConic(C1, C2)

p1 <- lattice::xyplot(y ~ x, data = ellipses, type = "l", groups = fac, asp = 1,
                      xlab = NULL, ylab = NULL,
                      scales = list(draw = FALSE, axes = FALSE),
                      par.settings = list(axis.line = list(col = "transparent")),
                      panel = function(x, y, ...) {
                        panel.xyplot(x, y, ..., col = c("black", "steelblue3"))
                      })
p2 <- lattice::xyplot(y ~ x, data = ellipses, type = "l", groups = fac, asp = 1,
                      xlab = NULL, ylab = NULL,
                      scales = list(draw = FALSE, axes = FALSE),
                      par.settings = list(axis.line = list(col = "transparent")),
                      panel = function(x, y, ...) {
                        panel.xyplot(x, y, ..., col = c("transparent", "steelblue3"))
                        panel.abline(a = -ll[3, 1]/ll[2, 1], b = -ll[1, 1]/ll[2, 1])
                        panel.abline(a = -ll[3, 2]/ll[2, 2], b = -ll[1, 2]/ll[2, 2])
                      })
p3 <- lattice::xyplot(y ~ x, data = ellipses, type = "l", groups = fac, asp = 1,
                      xlab = NULL, ylab = NULL,
                      scales = list(draw = FALSE, axes = FALSE),
                      par.settings = list(axis.line = list(col = "transparent")),
                      panel = function(x, y, ...) {
                        panel.xyplot(x, y, ..., col = c("transparent", "steelblue3"))
                        panel.abline(a = -ll[3, 1]/ll[2, 1], b = -ll[1, 1]/ll[2, 1])
                        panel.abline(a = -ll[3, 2]/ll[2, 2], b = -ll[1, 2]/ll[2, 2])
                        panel.points(t(pp[1:2, ]), col = 1)
                      })
c(p1, p2, p3, layout = c(3, 1))
```


### Areas of overlapping ellipses

## Visualization

# Results

## Consistency

## Accuracy

## Performance


# Discussion

# Pre-processing

# Initial configuration
Our initial layout can be setup in a number of ways; **eulerr** uses one of the 
methods from Fredrickson's [venn.js](https://github.com/benfred/venn.js/), which
features a constrained version of multi-dimensional scaling (MDS) based on that 
of Wilkinson's **R** package 
[venneuler](https://CRAN.R-project.org/package=venneuler) [@wilkinson_2012]. 
**venneuler** tries to place disjoint and subset exactly neck-in-neck and at the 
exact midpoint of the set respectively. However, since we are indifferent about
where in the space outside (or respectively inside) the sets are placed, that
behavior becomes problematic since it might interfere with locations of other
sets that need to occupy some of that space.

The MDS algorithm from **venn.js** circumvents this by assigning a loss and gradient
of 0 when, for instance, the set relationsships *and* the candidate ellipses are
disjoint. Then, to optimize the pairwise relationsships between sets, **eulerr**
uses the following loss and gradient functions.

> \[\small
> \text{loss} = \sum_i \sum_j { {\begin{cases}
>     0 & \text{disjoint}(i, j)\\ 
>     0 & \text{subset}(i, j)\\ 
>     ((X_{i} - X_{j})^T(X_{i} - X_{j}) - D_{ij}^2) ^2  & \text{otherwise} \\ 
> \end{cases}}}
> \]
>
> \[\small
> \nabla f(X_{i}) = \sum_j {\begin{cases}
>      \vec{0} & \text{disjoint}(i, j)\\ 
>      \vec{0} & \text{subset}(i, j)\\ 
>      4 {((X_{i} - X_{j})^T(X_{i} - X_{j}) - D_{ij}^2)} (X_{i} -
>      X_{j}) & \text{otherwise} \\ 
> \end{cases}}\]
> *Source: [Better Venn Diagrams](http://www.benfrederickson.com/better-venn-diagrams/)
> by Ben Fredrickson, which includes a nice interactive demonstration.*

Fredrickson uses the *Polak--Ribière Conjugate Gradient Method* to optimize
the initial layout. In our experience this method occasionally ends
up in local minima, which is why
we have opted to use `nlm()` from the **R** core package `stats`, which is a 
translation from FORTRAN code developed by @schnabel_1985 and uses a mixture of
algorithms (Newton and Quasi-Newton).

This initial configuration will work perfectly for any 1--2 set combinations
and as well as possible with 3 sets if we use circles but for all other
combinations there is usually a need to fine tune the configuration.

# Final configuration
In order to finalize the configuration we need to be able to compute the areas
of the overlaps of the sets, which as it turns out, is *not* trivial. In fact,
most of methods rely on approximations of the areas by, for instance, quad-tree
binning (**venneuler**) or polygon intersections (**VennMaster**
[@kestler_2008]). These methods yield reasonable estimates but, given that the
computation may have to run for a vast number of iterations, are usually
prohibitive in terms of performance.

**venn.js** and **eulerAPE** both, however, use exact algorithms. Based on the
fact that any intersection of ellipses can be represented as a convex polygon
with elliptical segments on the fringes, it is possible to arrive at exact area
calculations.

## Intersections

Finding the areas of the overlaps exactly requires that we first know the points
at which the different ellipses intersect. **eulerr**'s approach to this is based
on a method outlined by @richter-gebert_2011.
**eulerr** owes significant debt to the **R** package **RConics**
[@huber_2014], which has been tremendously helpful
in developing and, especially, debugging the algorithm. Some parts of the code
are in fact straight-up translations to C++ from the code in **RConics**.

The method is based in *projective geometry* (rather than euclidean). To find
the intersection points, the algorithm first

* converts the two ellipses from canonical form to matrix notation. The 
canonical form of a rotated ellipse is given by
\[
\frac{((x-h)\cos(\phi)+(y-k)\sin(\phi))^2}{a^2}+\frac{((x-h) \sin(A)-(y-k)
  \cos(\phi))^2}{b^2} = 1,
\]
where *phi* is the counter-clockwise angle from the positive x axis to the 
semi-major axis *a*. *b* is the semi-minor axis whilst *(h, k)* is the center
of the ellipse. This is then converted to the matrix form
\[
E = \begin{bmatrix}A & B/2 & D/2 \\
                   B/2 & C & E/2 \\
                   D/2 & E/2 & F
    \end{bmatrix},
\]
which may be used to represent any conic. We then
* split one of the ellipses (conics) into a pencil of two lines, and subsequently
* intersect the remaining conic with these two lines, which will yield between
0 and 4 intersection points.

---
TODO: Add some illustrations of this.
---

## Areas
The next step is to calculate the area of overlap between all the
possible combinations of ellipses. The solution to this was discovered,
as far as I know, by Fredrickson who explains it beautifully in a 
[blog post](http://www.benfrederickson.com/calculating-the-intersection-of-3-or-more-circles/).
It relies on finding all the intersection points between the currently
examined sets that are also within these sets. It is then trivial to find the
area of the convex polygon that these vertices make up. Finding the 
rest of the area, which is made up of the ellipse segments between
subsequent points, requires a bit of trigonometry. 

Here, we have used an algorithm from @eberly_area_2016, which
computes circle integral between the points on the ellipse minus the 
area of the triangle made up of the center of the ellipse: 
\[
A(\theta_0, \theta_1) = F(\theta_1) - F(\theta_1) -
\frac{1}{2}|x_1y_0 - x_0y_1|,
\]
\[
\text{where } F(\theta) = \frac{a}{b}\left[ \theta -
\arctan{\left(\frac{(b - a)\sin{2\theta}}{b + a +(b - a )\cos{2\theta}} \right)}
\right]
\]

As our loss function, we use the sum of squared differences between the 
disjoint set intersections and the areas we have computed and again use the `nlm()`
optimizer to layout the set. 

This optimization step is the bottleneck of the overall computations in terms of
performance, being that 
we're optimizing over 5 parameters for every ellipse (or 3 in the case
of circles) -- nevertheless, we're profitting immensely from the implementation
in the C++ programming language through **Rcpp** [@eddelbuettel_2011] and its
plugin for the linear algebra library **Armadillo** [@eddelbuettel_2014] which
ends up making the code much faster than the java-based **venneuler**.

# Layout
Since the optimization steps are unconstrained, we run the risk of
ending up with dispersed layouts. To fix this, we use the SKYLINE-BL 
rectangle packing algorithm [@jylanki_2010] to pack the disjoint clusters of
ellipses (in case there are any) into a heuristically chosen bin.

At the time of writing this algorithm is crudely implemented -- for 
instance, it does not attempt to rotate the rectangles (boundaries for the
ellipses) or attempt to use. Since we're dealing with a rather simple version
of the rectangle packing problem, however, it seems to do the trick.

# Output
Before we get to plotting the solution, it is useful to know how well the
fit from **eulerr** matches the input. Sometimes euler diagrams are just not
feasible, particular for combinations with many sets, in which case we should
stop here and look for another design to visualize the set relationships.

It is not, however, obvious what it means for a euler diagram to "fit well". 
**venneuler** uses a metric called *stress*, which is defined as
\[
\frac{\sum_{i=1}^{n} (y_i - \hat{y}_i) ^ 2}{\sum_{i=1}^{n} y_i ^ 2}
\]
where $\hat{y}_i$ is an ordinary least squares estimate from the regression of
the fitted areas on the original areas that is being explored during
optimization.

Meanwhile, **eulerAPE** [@micallef_2014] uses *diagError*:
\[
\max_{i = 1, 2, \dots, n} \left| \frac{y_i}{\sum y_i} -
  \frac{\hat{y}_i}{\sum \hat{y}_i} \right|
\]

Both metrics are given the user after the diagram has been fit, together
with a table of residuals.

```{r, fig.cap = "A plot with circles."}
combo <- c("A" = 1, "B" = 1, "C" = 1,
           "A&B" = 0.5, "A&C" = 0.5, "C&B" = 0.5)

fit1 <- euler(combo)
fit1
plot(fit1, counts = TRUE)
```

It is clear that this is not a good fit, which we can find out just by
looking at the plot. This is a good example of when ellipses come in handy.

```{r, fig.cap = "A plot with ellipses."}
fit2 <- euler(combo, shape = "ellipse")
fit2
plot(fit2, counts = TRUE)
```

Much better.

[TODO]: # What is a high and low diag_error?

# Plotting
Let's face it: euler diagrams are naught without visualization. Here, **eulerr**
interfaces the elegant Lattice graphics system [@sarkar_2008] to grant the
user extensive control over the output, and allow for facetted plots in
case such a design was used in fitting the euler configuration.

## Labelling
Most users will want to label their euler diagrams. One option is to simply 
add a legend

```{r, fig.cap = "A simple plot."}
plot(euler(c(A = 2, B = 3, "A&B" = 1)), auto.key = TRUE)
```

but many will want to label their diagrams directly, perhaps with counts.

```{r, fig.cap = "A plot with counts."}
plot(euler(c(A = 2, B = 3, "A&B" = 1)), counts = TRUE)
```

In this case, layout out the diagram becomes considerably more involved. Finding
a reasonable spot for the text inside the diagram only lends itself to an
easy solution if the shape of the intersection has a center-of-gravity inside
ellipse, in which case an average of some of the points might suffice. This
is often not the case, however, and we need a better solution. Specifically,
what we need is a method to find the point inside the circle overlap for the
counts and circle complement to the intersection for our labels.

So far, we have not been able to derive at an analyitcal solution for
finding a good point, or for that matter a reliable way of finding *any* point
that is in the required intersection or complement. As is often the case,
the next-best thing turns out to be a numerical one. First, we locate a 
point that is inside the required region by spreading points across one of the
discs involed in the set combination. To spread points uniformly, we use
*Vogel's method* [@arthur_2015; @vogel_1979]
\[
\left( p_k = (\rho_k, \theta_k) = \left( r \sqrt{\frac{k}{n}},\, \pi (3 - \sqrt{5})(k - 1) \right) \right)_{k=1}^n,
\]
which is actually based on the golden angle.

```{r, fig.cap = "Spreading points on a disc with Vogel's method."}
n <- 500
seqn <- seq(1, n, 1)
theta <- seqn*pi*(3 - sqrt(5))
rad <- sqrt(seqn/n)
x <- rad*cos(theta)
y <- rad*sin(theta)

xyplot(x ~ y, aspect = "iso", pch = 20, xlab = "", ylab = "",
       col = 1,
       par.settings = list(axis.line = list(col = "transparent")),
       scales = list(draw = FALSE))
```

After this, we scale, translate,
and rotate the points so that they fit the desired ellipse.

---
TODO: Visualize this step.
---

After we've spread our points throughout the ellipse and found one that
matches our desired combination of ellipses/sets, we then proceed to optimize
its position numerically. For this, we use version of the
*Nelder--Mead Method* [@nelder_1965] which we've translated from Matlab
code by @kelley_1999 and customized for **eulerr**
(in particular to make sure that
the simplex does not escape the intersection boundaries since we for this
problem *want* the local minimum).

## Coloring
Per default, the ellipses are filled with colors. The default option is to
use an adaptive scheme in which colors are chosen to provide a balance
between dinstinctiveness, beauty, and consideration for the color deficient.
The color palette has been generated from
[qualpalr](https://CRAN.R-project.org/package=qualpalr)
(developed by the author), which automatically generates qualitative color
palettes based on a model of color perception.

# References
